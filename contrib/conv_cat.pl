#!/usr/bin/perl

use Data::Dumper;

my @cats = sort(
"Accessibility",
"Settings",
"Screensavers",
"Accessories",
"Development",
"Education",
"Game",
"Graphics",
"Multimedia",
"Audio",
"Video",
"AudioVideo",
"Network",
"Office",
"Science",
"System",
"WINE",
"Editors",
"Utility",
"Other"
);

print "// WARNING: this is an autogenerated file. Any change might be overwritten!\n";
use strict;
#my %grps, my %secs, my %hints;
#$grps{"ANY"} = '';

my %mapping;
my @stable;
my @scats;
my %scat_lookup;

sub uniq {
    my %seen;
    grep !$seen{$_}++, @_;
}

for(<>)
{
	chomp;
	my @toks = split(/\s*,\s*|\s*;\s*|\s+or\s+/);
	# trim them
	@toks = map { $_=~s/^\s*//; $_=~s/\s*$//; $_ } @toks;
	#print Dumper(@toks);
	push(@stable, \@toks);
	# collect all seen subcategory strings
	push(@scats, $toks[0]);
	$scat_lookup{$toks[0]} = @toks[1..$#toks];
	#next if $sec eq "GTK" or $sec eq "Qt" or $sec eq "GNOME" or $sec eq "KDE" or $sec eq "XFCE" or $sec eq "Java" or $sec eq "ConsoleOnly";
	# key is sanitized name of the filter set or ANY for no filters
	#my $subcat = shift(@toks);
	# expand to all categories
	#@toks = @cats unless @toks;
	#push(@toks, "-") unless length(join("", @toks));
	##$mapping{$key} = @toks;
	#for my $maincat (uniq(@toks)) {
#		next if ! length($maincat);
#		if ($mapping{$subcat}) {
#			push(@{$mapping{$subcat}}, $maincat);
#		}
#		else {
#			$mapping{$subcat} = [$maincat] ;
#		}
#	}
}

errrrror ab hier die referenzen mehrfach aufloesen bis alles nur noch auf maincats verweist

# start of the list, the end of the list are 
print "
#include \"intl.h\"
#include <tuple>
namespace spec {

using mstring = const char*;
using mapping = std::tuple<mstring, mstring /*, mstring */>;

namespace mcat {	
	".join("\n\t", map { "
	// TRANSLATORS: This is a menu category name from https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry . Please add spaces as needed but no double-quotes.
	const auto x$_ = N_(\"$_\");" } @cats)."

	const mstring sall[] = {
		".join(",\n\t\t", map { "x$_" } @cats)."
	};
}

namespace scat {
	".join("\n\t", map { "
	// TRANSLATORS: This is a menu category name from https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry . Please add spaces as needed but no double-quotes.
	const auto x$_ = N_(\"$_\");" } @scats)."
}

static mapping subcat_to_maincat[] = {
";

#print "const char* $_\[\] = { \"$grps{$_}\", \"|\", nullptr };\n" for(sort keys %grps);

print "
// statically presorted list of sub category mapping. See fdomenu.cc for details.
";

my @scam;

for my $x ( sort { ${$a}[0] cmp ${$b}[0]} (@stable)) {
	my @l = @{$x};
	my $scat = shift(@l);
	if (@l) {
		for my $y (uniq( sort { $a cmp $b } (@l))) {
			my $true_cat = $y;
			while (! grep { $_ eq $y } @cats) {

			}

			if ( grep { $_ eq $y } @cats) {
				push(@scam, "\t{ scat::x$scat, mcat::x$y /*, nullptr */ }");
			}
			else {
				my $true_cat = $y;
				
				push(@scam, "\t{ scat::x$scat, nullptr /*, scat::x$y */ }");
			}
		}
	}
	else {
		push(@scam, "\t{ scat::x$scat, nullptr /*, nullptr */ }");
	}
}
print join(",\n", uniq(@scam));
print "
	};
}
";


exit(0);


for my $subcatkey (sort(keys %mapping))
{
	for my $mcatref (@{$mapping{$subcatkey}}) {
		print "\t// TRANSLATORS: This is a menu category name from https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry . Please add spaces as needed but no double-quotes.\n";
		print "\t{ \"$subcatkey\", \"$mcatref\" },\n";
	}
	
#	my $ptr = $secs{$_} ? "&$secs{$_}" : "nullptr";
#	print "// TRANSLATORS: This is a menu category name from https://specifications.freedesktop.org/menu-spec/menu-spec-1.0.html#category-registry . Please add spaces as needed but no double-quotes.".($hints{$_} ? " Context: $hints{$_}\n" : "\n");
#	print "    { N_(\"$_\"), \"folder\", (const char**) $ptr}";
#	print $_ eq $cats[-1] ? "\n" : ",\n";
}
print "};
}
";
